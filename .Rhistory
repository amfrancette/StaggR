res <- render_data(); req(res)
step_names <- names(res$colors); step_colors <- unname(res$colors)
font_colors_step <- ifelse(sapply(step_colors, is_color_dark), 'white', 'black')
if ("Step" %in% visible_cols) {
dt <- dt %>% formatStyle('Step', backgroundColor = styleEqual(step_names, step_colors), color = styleEqual(step_names, font_colors_step))
}
sample_names  <- names(res$sample_colors); sample_colors <- unname(res$sample_colors)
font_colors_sample <- ifelse(sapply(sample_colors, is_color_dark), 'white', 'black')
if ("Sample" %in% visible_cols) {
dt <- dt %>% formatStyle('Sample', backgroundColor = styleEqual(sample_names, sample_colors), color = styleEqual(sample_names, font_colors_sample))
}
}
dt
})
# Renders the "Schedule by Sample" data table.
output$scheduleBySample <- DT::renderDataTable({
df <- schedule_sample_df(); if (is.null(df)) return(NULL)
res <- render_data(); if(is.null(res)) return(NULL)
dt <- DT::datatable(df, rownames = TRUE, options = list(pageLength = 20, dom = 'lfrtip'))
if (isTRUE(input$colorCodeTables)) {
step_names <- names(res$colors); step_colors <- unname(res$colors)
font_colors <- ifelse(sapply(step_colors, is_color_dark), 'white', 'black')
names(step_colors) <- step_names; names(font_colors) <- step_names
for (col_name in colnames(df)) {
if (col_name %in% step_names) {
dt <- dt %>% formatStyle(col_name, backgroundColor = step_colors[col_name], color = font_colors[col_name])
}
}
}
dt
})
# --- Live Time Course Functionality ---
# Reactive values to manage the state of the live timer.
experiment_start_at     <- reactiveVal(NULL)
current_segment_index   <- reactiveVal(0L)
timer_active            <- reactiveVal(FALSE)
timer_pre_start         <- reactiveVal(FALSE)
time_remaining          <- reactiveVal(0)
timer_mode              <- reactiveVal("idle")
event_end_at            <- reactiveVal(Sys.time())
timer_paused            <- reactiveVal(FALSE)
time_remaining_at_pause <- reactiveVal(0)
# Helper functions to deconstruct the schedule for the live timer display.
.make_timeline_segments <- function(sched) {
if (is.null(sched) || nrow(sched) == 0) return(data.frame(kind=character(), idx=integer(), start_sec=integer(), end_sec=integer()))
starts <- round(sched$TimeNumeric * 60); durs <- pmax(0L, round(sched$DurationNumeric * 60))
segs <- list(); cursor <- 0L
for (i in seq_len(nrow(sched))) {
if (starts[i] > cursor) segs[[length(segs) + 1]] <- data.frame(kind="wait", idx=i, start_sec=cursor, end_sec=starts[i])
if (durs[i] > 0L) segs[[length(segs) + 1]] <- data.frame(kind="step", idx=i, start_sec=starts[i], end_sec=starts[i] + durs[i])
cursor <- max(cursor, starts[i] + durs[i])
}
do.call(rbind, segs)
}
.prev_step_index <- function(sched, ref_idx) { cand <- which(sched$DurationNumeric > 0 & seq_len(nrow(sched)) < ref_idx); if (length(cand) == 0) NA_integer_ else max(cand) }
.next_step_index <- function(sched, ref_idx) { cand <- which(sched$DurationNumeric > 0 & seq_len(nrow(sched)) > ref_idx); if (length(cand) == 0) NA_integer_ else min(cand) }
segments <- reactive({ req(results()); .make_timeline_segments(schedule_time_df()) })
# UI and state management for timer controls.
output$startResumeButton <- renderUI({
label <- if (isTRUE(timer_paused())) "Resume" else "Start Time Course"
icon_name <- if (isTRUE(timer_paused())) "play-circle" else "play-circle"
actionButton("startTimer", label, icon = icon(icon_name), class = "btn-success", style="margin-top: 25px; width: 100%;")
})
observe({
active <- timer_active(); paused <- timer_paused()
shinyjs::toggleState("startTimer", condition = !active || paused)
shinyjs::toggleState("pauseTimer", condition = active && !paused)
shinyjs::toggleState("stopTimer", condition = active)
})
# Event handlers for timer buttons.
observeEvent(input$startTimer, {
# This block handles the "Start" and "Resume" actions for the live timer.
if (isTRUE(timer_paused())) {
# Logic for resuming a paused timer.
timer_paused(FALSE)
event_end_at(Sys.time() + time_remaining_at_pause())
showNotification("Time course resumed.", type = "message")
} else {
# Logic for starting a new timer run.
sched <- schedule_time_df()
# Use a standard 'if' condition for validation within an observer.
if (is.null(sched) || nrow(sched) == 0) {
showNotification("Please generate a schedule first.", type = "error")
return() # Stop execution
}
showNotification("Starting time course...", type = "message")
timer_pre_start(TRUE); timer_mode("pre"); timer_active(TRUE)
current_segment_index(0L); experiment_start_at(NULL)
event_end_at(Sys.time() + as.numeric(input$countdownStart))
time_remaining(as.numeric(input$countdownStart))
}
})
observeEvent(input$pauseTimer, {
req(timer_active(), !isTRUE(timer_paused()))
rem <- as.numeric(difftime(event_end_at(), Sys.time(), units = "secs"))
time_remaining_at_pause(max(0, rem))
timer_paused(TRUE)
showNotification("Time course paused.", type = "warning")
})
observeEvent(input$stopTimer, {
timer_active(FALSE); timer_paused(FALSE); timer_pre_start(FALSE); timer_mode("idle")
current_segment_index(0L); experiment_start_at(NULL)
df <- schedule_time_df()
if(!is.null(df)){
df$Status <- "upcoming"
replaceData(dataTableProxy("scheduleByTime"), df %>% select(any_of(c("Status", "Sample", "Step", isolate(input$showCols)))), resetPaging = FALSE, rownames = FALSE)
}
showNotification("Time course stopped and reset.", type = "error")
})
# The main timer loop, which invalidates every 200ms to update the display.
observe({
req(timer_active(), !isTRUE(timer_paused())); invalidateLater(200, session)
now <- Sys.time(); rem <- as.numeric(difftime(event_end_at(), now, units = "secs"))
time_remaining(max(0, ceiling(rem)))
if (rem > 0) return() # Do nothing until the current segment ends.
segs <- segments(); req(segs)
if (timer_mode() == "pre") {
timer_pre_start(FALSE); timer_mode("run"); experiment_start_at(now)
seg_idx <- 1L
while (seg_idx <= nrow(segs) && (segs$end_sec[seg_idx] - segs$start_sec[seg_idx]) <= 0) seg_idx <- seg_idx + 1L
if (seg_idx > nrow(segs)) { timer_active(FALSE); timer_mode("done"); showNotification("Time course complete!", type="message"); return() }
current_segment_index(seg_idx)
event_end_at(experiment_start_at() + segs$end_sec[seg_idx])
} else if (timer_mode() == "run") {
next_idx <- current_segment_index() + 1L
while (next_idx <= nrow(segs) && (segs$end_sec[next_idx] - segs$start_sec[next_idx]) <= 0) next_idx <- next_idx + 1L
if (next_idx > nrow(segs)) { timer_active(FALSE); timer_mode("done"); showNotification("Time course complete!", type="message") }
else { current_segment_index(next_idx); event_end_at(experiment_start_at() + segs$end_sec[next_idx]) }
}
})
# Observer that updates the chronological table rows' status during a live run.
observe({
# This observer depends on the timer and the checkbox.
time_remaining()
# Only execute the update logic if the timer is active AND the box is checked.
if (isTRUE(timer_active()) && isTRUE(input$liveTableUpdates)) {
req(!is.null(experiment_start_at()), !isTRUE(timer_paused()))
df <- schedule_time_df()
req(df)
now_sec <- as.numeric(difftime(Sys.time(), experiment_start_at(), units = "secs"))
starts_sec <- df$TimeNumeric * 60
ends_sec <- (df$TimeNumeric + df$DurationNumeric) * 60
df$Status <- ifelse(now_sec >= ends_sec, "past",
ifelse(now_sec >= starts_sec & now_sec < ends_sec, "active", "upcoming"))
# Use a proxy to update the data without redrawing the whole table.
replaceData(dataTableProxy("scheduleByTime"),
df %>% select(any_of(c("Status", "Sample", "Step", isolate(input$showCols)))),
resetPaging = FALSE,
rownames = FALSE)
}
})
# Renders the text for the sticky header above the chronological schedule.
output$liveElapsedCaption <- renderText({
time_remaining(); if(!timer_active()) return("Time Course Idle")
now_sec <- if (is.null(experiment_start_at())) 0 else as.numeric(difftime(Sys.time(), experiment_start_at(), units = "secs"))
if(isTRUE(timer_paused())){ res <- results(); if(!is.null(res)){ now_sec <- (max(res$plot_data$end) * 60) - time_remaining_at_pause() }}
elapsed_str <- format_hhmmss(max(0, now_sec) / 60)
detail_str <- if (isTRUE(timer_paused())) { "PAUSED" } else {
rem_str <- format_hhmmss(time_remaining()/60)
header_title <- if (timer_mode() == "pre") "Countdown to Start" else if (timer_mode() == "run") {
segs <- segments(); sidx <- current_segment_index(); if (is.null(segs) || sidx < 1 || sidx > nrow(segs)) "Calculating..." else { if (segs[sidx, ]$kind == "step") "Time Left in Current Step" else "Time Until Next Step" }
} else "Complete"
paste0(header_title, " - ", rem_str)
}
paste("Live Elapsed -", elapsed_str, "|", detail_str)
})
# Renders the detailed display for the "Live Time Course" tab.
output$liveTimerDisplay <- renderUI({
# Display an idle message if the timer isn't active.
if (!timer_active()) {
return(div(style="text-align: center; padding: 20px;",
h4("Ready to start time course."),
p("Generate a schedule first, then click 'Start Time Course'.")
))
}
# These helpers create the styled boxes for the UI.
make_step_box <- function(row, title, highlight = FALSE) {
if (is.null(row) || nrow(row) == 0) return(NULL)
res <- render_data()
bg_step <- res$colors[row$Step] %||% "#DDDDDD"; fg_step <- ifelse(is_color_dark(bg_step), "white", "black")
sample_name_char <- as.character(row$Sample)
bg_smpl <- res$sample_colors[sample_name_char] %||% "#DDDDDD";
fg_smpl <- ifelse(is_color_dark(bg_smpl), "white", "black")
div(class = "livecard", style = paste0("border:1px solid #ccc; border-radius:6px; padding:12px; margin-bottom:12px; opacity:", if(highlight) 1 else 0.85, ";"),
h4(title), fluidRow(
column(6, p(strong("Sample: "), span(class="badge-sample", style=paste0("background-color:", bg_smpl, "; color:", fg_smpl, ";"), row$Sample))),
column(6, p(strong("Step: "), span(class="badge-chip", style=paste0("background-color:", bg_step, "; color:", fg_step, ";"), row$Step)))
), p(strong("Start: "), row$Time, " | ", strong("Duration: "), row$Duration)
)
}
make_info_box <- function(title, body) { div(class="livecard", style="border: 1px dashed #bbb; border-radius: 6px; padding: 12px; margin-bottom: 12px; background-color:#f7f7f7;", h4(title), body) }
# Calculate elapsed time strings.
now <- Sys.time(); t0 <- experiment_start_at(); elapsed_sec <- if (is.null(t0)) 0 else max(0, as.numeric(difftime(now, t0, units = "secs")))
if(isTRUE(timer_paused())){ res <- results(); if(!is.null(res)){ elapsed_sec <- (max(res$plot_data$end) * 60) - time_remaining_at_pause() } }
elapsed_str <- format_hhmmss(elapsed_sec / 60)
countdown_display <- if (isTRUE(timer_paused())) h1(style="font-size: 3.5em; font-weight: bold; color: #E0A800;", "PAUSED") else h1(style="font-size: 3.5em; font-weight: bold;", format_hhmmss(time_remaining()/60))
sched <- schedule_time_df(); req(sched)
# --- UI Logic for Pre-Start Countdown View ---
if (timer_pre_start()) {
first_idx <- if (nrow(sched) >= 1) 1L else NA_integer_
next_idx  <- if (!is.na(first_idx)) .next_step_index(sched, first_idx) else NA_integer_
first_row <- if (is.na(first_idx)) NULL else sched[first_idx, , drop=FALSE]
next_row  <- if (is.na(next_idx))  NULL else sched[next_idx, , drop=FALSE]
return(tagList(
fluidRow(
column(8, offset = 2,
div(style="text-align: center; background-color: #f2f2f2; border-radius: 10px; padding: 20px;",
h3("Countdown to Start"),
countdown_display,
br(), h5(span(style="opacity:0.8;", "Elapsed since T0: "), strong(elapsed_str))
)
)
),
br(),
fluidRow(
column(6, make_step_box(first_row, "First Step (up next)", TRUE)),
column(6, make_step_box(next_row,  "Next Step"))
)
))
}
# --- UI Logic for Main Running View ---
segs <- segments(); req(nrow(segs) > 0)
sidx <- current_segment_index(); seg <- segs[sidx, ]
if (seg$kind == "step") {
cur_step_row  <- sched[seg$idx, , drop=FALSE]
prev_idx      <- .prev_step_index(sched, seg$idx)
next_idx      <- .next_step_index(sched, seg$idx)
prev_step_row <- if (is.na(prev_idx)) NULL else sched[prev_idx, , drop=FALSE]
next_step_row <- if (is.na(next_idx)) NULL else sched[next_idx, , drop=FALSE]
current_panel <- make_step_box(cur_step_row, "Current Step", TRUE)
header_title  <- "Time Left in Current Step"
} else { # "wait"
prev_idx      <- .prev_step_index(sched, seg$idx)
next_idx      <- seg$idx
prev_step_row <- if (is.na(prev_idx)) NULL else sched[prev_idx, , drop=FALSE]
next_step_row <- sched[next_idx, , drop=FALSE]
current_panel <- make_info_box("Waiting / Incubation", p("Next: ", next_step_row$Sample, " â€” ", next_step_row$Step))
header_title  <- "Time Until Next Step"
}
# This tagList defines the final layout for the main running view.
tagList(
fluidRow(
column(8, offset = 2,
div(style="text-align: center; background-color: #f2f2f2; border-radius: 10px; padding: 20px;",
h3(header_title),
countdown_display,
br(), h5(span(style="opacity:0.8;", "Elapsed since T0: "), strong(elapsed_str))
)
)
),
br(),
fluidRow(
column(4, make_step_box(prev_step_row, "Previous Step")),
column(4, current_panel),
column(4, make_step_box(next_step_row, "Next Step"))
)
)
})
# --- Save/Load and Export Functionality ---
# Handler to Save the FULL Session to a .json file
output$saveSession <- downloadHandler(
filename = function() {
sanitized_name <- gsub("[^A-Za-z0-9_]", "_", input$chartName %||% "Protocol")
paste0(sanitized_name, "_StaggR_Session_", Sys.Date(), ".json")
},
content = function(file) {
st <- steps_state(); req(st); n_steps <- nrow(st)
if (!is.null(input[[paste0("stepName", n_steps)]])) {
for (i in 1:n_steps) {
st$step_name[i] <- input[[paste0("stepName", i)]]
st$step_duration_value[i] <- input[[paste0("stepDuration", i)]]
st$step_duration_unit[i] <- input[[paste0("durUnit", i)]]
st$step_color[i] <- input[[paste0("stepColor", i)]]
if (i < n_steps) {
st$time_to_next_value[i] <- input[[paste0("timeToNext", i)]]
st$time_to_next_unit[i] <- input[[paste0("ttnUnit", i)]]
}
}
}
accessory_params <- list(
chartName = input$chartName, sampleNames = input$sampleNames,
optMode = input$optMode, manualIntervalValue = input$manualIntervalValue,
manualIntervalUnit = input$manualIntervalUnit, taskSwitchValue = input$taskSwitchValue,
taskSwitchUnit = input$taskSwitchUnit, granularity = input$granularity,
xAxisValue = input$xAxisValue, xAxisUnit = input$xAxisUnit,
overbookedColor = input$overbookedColor, bufferColor = input$bufferColor,
shadingColor = input$shadingColor, sampleColorBase = input$sampleColorBase
)
full_session <- list(staggR_version = "2.0", protocol_steps = st, accessory_params = accessory_params)
write(jsonlite::toJSON(full_session, pretty = TRUE, auto_unbox = TRUE), file)
}
)
# Handler to Save ONLY the Protocol Steps to a .csv file
output$saveProtocol <- downloadHandler(
filename = function() {
sanitized_name <- gsub("[^A-Za-z0-9_]", "_", input$chartName %||% "Protocol")
paste0(sanitized_name, "_Protocol_Parameters_", Sys.Date(), ".csv")
},
content = function(file) {
st <- steps_state(); req(st)
# Future-proofing: could also gather from UI here like in saveSession.
write.csv(st, file, row.names = FALSE, na = "")
}
)
# Observer for the main file upload input.
observeEvent(input$uploadSession, {
req(input$uploadSession); file_info <- input$uploadSession
tryCatch({
if (tools::file_ext(file_info$name) == "json") {
params <- jsonlite::fromJSON(file_info$datapath, simplifyVector = TRUE)
load_session_params(params)
showNotification("Session file (.json) loaded successfully.", type = "message")
} else { # For backward compatibility with old CSV files
params <- read.csv(file_info$datapath, stringsAsFactors = FALSE, na.strings = c("NA", ""))
suppress_nsteps_sync(TRUE); updateNumericInput(session, "nSteps", value = nrow(params)); steps_state(params)
showNotification("Legacy parameters (.csv) loaded.", type = "warning")
}
}, error = function(e) { showNotification(paste("Error reading file:", e$message), type = "error") })
})
# Helper function to load parameters from a list (read from JSON).
load_session_params <- function(params) {
# Perform validation using standard if conditions, which are safer inside observers.
if (!("protocol_steps" %in% names(params))) {
showNotification("Invalid JSON: File is missing the required 'protocol_steps' object.", type = "error", duration = 8)
return(NULL) # Stop execution of this function
}
if (!("accessory_params" %in% names(params))) {
showNotification("Invalid JSON: File is missing the required 'accessory_params' object.", type = "error", duration = 8)
return(NULL) # Stop execution of this function
}
protocol_df <- as.data.frame(params$protocol_steps)
accessory <- params$accessory_params
# Update all UI inputs from the loaded data.
updateTextInput(session, "chartName", value = accessory$chartName)
updateTextAreaInput(session, "sampleNames", value = accessory$sampleNames)
updateRadioButtons(session, "optMode", selected = accessory$optMode)
updateNumericInput(session, "manualIntervalValue", value = accessory$manualIntervalValue)
updateSelectInput(session, "manualIntervalUnit", selected = accessory$manualIntervalUnit)
updateNumericInput(session, "taskSwitchValue", value = accessory$taskSwitchValue)
updateSelectInput(session, "taskSwitchUnit", selected = accessory$taskSwitchUnit)
updateSelectInput(session, "granularity", selected = accessory$granularity)
updateNumericInput(session, "xAxisValue", value = accessory$xAxisValue)
updateSelectInput(session, "xAxisUnit", selected = accessory$xAxisUnit)
updateColourInput(session, "overbookedColor", value = accessory$overbookedColor)
updateColourInput(session, "bufferColor", value = accessory$bufferColor)
updateColourInput(session, "shadingColor", value = accessory$shadingColor)
updateColourInput(session, "sampleColorBase", value = accessory$sampleColorBase)
suppress_nsteps_sync(TRUE)
updateNumericInput(session, "nSteps", value = nrow(protocol_df))
steps_state(protocol_df)
}
# A helper function to load an example session from a file path.
load_example <- function(file_path) {
tryCatch({
if (!file.exists(file_path)) {
showNotification(paste("Error: Example file not found at", file_path), type = "error", duration = 8); return()
}
params <- jsonlite::fromJSON(file_path, simplifyVector = TRUE)
load_session_params(params)
updateTabsetPanel(session, "main_tabs", selected = "Gantt Chart")
showNotification(paste("Loaded example |", params$accessory_params$chartName, "| Generate a fresh schedule to update"), type = "message", duration = 5)
}, error = function(e) { showNotification(paste("Error parsing example file:", e$message), type = "error", duration = 8) })
}
# Observers for the "Load Example" buttons.
observeEvent(input$load_rnalabel, { load_example("data/RNA_labeling_params.json") })
observeEvent(input$load_degron,   { load_example("data/degron_time_course_params.json") })
observeEvent(input$load_fixation, { load_example("data/formaldehyde_fixation_params.json") })
# Handlers for downloading plots and reports.
output$confirmDownloadPlot <- downloadHandler(
filename = function() {
sanitized_name <- gsub("[^A-Za-z0-9_]", "_", input$chartName %||% "Protocol")
paste0(sanitized_name, "_Gantt_Chart_", Sys.Date(), ".", input$plotFormat)
},
content = function(file) {
res <- results(); req(res)
x_int_min <- to_minutes(input$xAxisValue, input$xAxisUnit)
plot_to_download <- generate_gantt_plot(res, input$plotShowLegend, input$alternateShading, input$shadingColor,
x_axis_interval = x_int_min, chart_name = input$chartName,
show_hhmmss = input$show_hhmmss, show_wait_times = input$showWaitTimes,
is_manual_mode = identical(input$optMode, "manual"))
ggsave(file, plot = plot_to_download, device = input$plotFormat,
width = input$plotWidth, height = input$plotHeight, units = "in", dpi = 300)
}
)
output$downloadTimeExcel <- downloadHandler(
filename = function() { paste0(gsub("[^A-Za-z0-9_]", "_", input$chartName %||% "Protocol"), "_schedule_by_time.xlsx") },
content = function(file) {
res <- render_data(); req(res); df <- schedule_time_df(); req(df)
show_status <- FALSE # Don't include Status column for live updates if downloading the excel
df_export <- if (!show_status) df %>% select(Sample, Step, Time, Duration, `Wait Until Next` = Wait_Until_Next) else df %>% select(Status, Sample, Step, Time, Duration, `Wait Until Next` = Wait_Until_Next)
wb <- openxlsx::createWorkbook(); openxlsx::addWorksheet(wb, "Schedule by Time"); openxlsx::writeDataTable(wb, "Schedule by Time", df_export, tableName = "ScheduleByTime")
hdr_style <- openxlsx::createStyle(textDecoration = "bold"); openxlsx::addStyle(wb, "Schedule by Time", hdr_style, rows = 1, cols = 1:ncol(df_export), gridExpand = TRUE)
if(isTRUE(input$colorCodeTables)){
step_names <- names(res$colors); step_colors <- unname(res$colors)
for(i in seq_along(step_names)) { style <- openxlsx::createStyle(fgFill = step_colors[i]); rows <- which(df_export$Step == step_names[i]) + 1; if(length(rows) > 0) openxlsx::addStyle(wb, "Schedule by Time", style, rows=rows, cols=which(names(df_export)=="Step"), gridExpand=TRUE, stack=TRUE) }
samp_names <- names(res$sample_colors); samp_colors <- unname(res$sample_colors)
for(i in seq_along(samp_names)) { style <- openxlsx::createStyle(fgFill = samp_colors[i]); rows <- which(df_export$Sample == samp_names[i]) + 1; if(length(rows) > 0) openxlsx::addStyle(wb, "Schedule by Time", style, rows=rows, cols=which(names(df_export)=="Sample"), gridExpand=TRUE, stack=TRUE) }
}
openxlsx::setColWidths(wb, "Schedule by Time", cols = 1:ncol(df_export), widths = "auto"); openxlsx::saveWorkbook(wb, file, overwrite = TRUE)
}
)
output$downloadSampleExcel <- downloadHandler(
filename = function() { paste0(gsub("[^A-Za-z0-9_]", "_", input$chartName %||% "Protocol"), "_schedule_by_sample.xlsx") },
content = function(file) {
res <- render_data(); req(res); df <- schedule_sample_df(); req(df)
wb <- openxlsx::createWorkbook(); openxlsx::addWorksheet(wb, "Schedule by Sample"); openxlsx::writeData(wb, "Schedule by Sample", df, rowNames = TRUE, tableName = "ScheduleBySample")
hdr_style <- openxlsx::createStyle(textDecoration = "bold"); openxlsx::addStyle(wb, "Schedule by Sample", hdr_style, rows = 1, cols = 1:(ncol(df)+1), gridExpand = TRUE)
if(isTRUE(input$colorCodeTables)){
step_names <- names(res$colors); step_colors <- unname(res$colors)
for (i in seq_along(step_names)) { hexcol <- step_colors[i]; if(step_names[i] %in% colnames(df)) { style  <- openxlsx::createStyle(fgFill = hexcol); openxlsx::addStyle(wb, "Schedule by Sample", style, rows = 2:(nrow(df)+1), cols = which(colnames(df) == step_names[i]) + 1, gridExpand = TRUE, stack = TRUE) } }
}
openxlsx::setColWidths(wb, "Schedule by Sample", cols = 1:(ncol(df)+1), widths = "auto"); openxlsx::saveWorkbook(wb, file, overwrite = TRUE)
}
)
output$confirmDownloadReport <- downloadHandler(
filename = function() { paste0(gsub("[^A-Za-z0-9_]", "_", input$chartName %||% "Protocol"), "_StaggR_Report_", Sys.Date(), ".zip") },
content = function(file) {
# Create a temporary directory to store files before zipping
temp_dir <- file.path(tempdir(), "StaggR_Report")
if (dir.exists(temp_dir)) unlink(temp_dir, recursive = TRUE)
dir.create(temp_dir, showWarnings = FALSE, recursive = TRUE)
# Set working directory to temp and ensure it's reset on exit
owd <- getwd(); setwd(temp_dir); on.exit(setwd(owd))
files_to_zip <- c() # Initialize list of files to be zipped
if("plot" %in% input$reportContents) {
req(results())
plot_path <- "Gantt_Chart.pdf"
x_int_min <- to_minutes(input$xAxisValue, input$xAxisUnit)
plot_to_download <- generate_gantt_plot(results(), TRUE, input$alternateShading, input$shadingColor,
x_axis_interval = x_int_min, chart_name = input$chartName,
show_hhmmss = input$show_hhmmss, show_wait_times = input$showWaitTimes,
is_manual_mode = identical(input$optMode, "manual"))
ggsave(plot_path, plot = plot_to_download, device = "pdf", width = 11, height = 8.5, units = "in")
files_to_zip <- c(files_to_zip, plot_path)
}
if("params_json" %in% input$reportContents) {
req(steps_state())
json_path <- "StaggR_Session.json"
st <- steps_state(); n_steps <- nrow(st)
if (!is.null(input[[paste0("stepName", n_steps)]])) {
for (i in 1:n_steps) {
st$step_name[i] <- input[[paste0("stepName", i)]]
st$step_duration_value[i] <- input[[paste0("stepDuration", i)]]
st$step_duration_unit[i] <- input[[paste0("durUnit", i)]]
st$step_color[i] <- input[[paste0("stepColor", i)]]
if (i < n_steps) {
st$time_to_next_value[i] <- input[[paste0("timeToNext", i)]]
st$time_to_next_unit[i] <- input[[paste0("ttnUnit", i)]]
}
}
}
accessory_params <- list(
chartName = input$chartName, sampleNames = input$sampleNames,
optMode = input$optMode, manualIntervalValue = input$manualIntervalValue,
manualIntervalUnit = input$manualIntervalUnit, taskSwitchValue = input$taskSwitchValue,
taskSwitchUnit = input$taskSwitchUnit, granularity = input$granularity,
xAxisValue = input$xAxisValue, xAxisUnit = input$xAxisUnit,
overbookedColor = input$overbookedColor, bufferColor = input$bufferColor,
shadingColor = input$shadingColor, sampleColorBase = input$sampleColorBase
)
full_session <- list(staggR_version = "2.0", protocol_steps = st, accessory_params = accessory_params)
write(jsonlite::toJSON(full_session, pretty = TRUE, auto_unbox = TRUE), json_path)
files_to_zip <- c(files_to_zip, json_path)
}
if("params_csv" %in% input$reportContents) {
req(steps_state())
params_path <- "protocol_parameters.csv"
write.csv(steps_state(), params_path, row.names = FALSE, na = "")
files_to_zip <- c(files_to_zip, params_path)
}
if("time_sched" %in% input$reportContents) {
req(schedule_time_df())
time_path <- "schedule_by_time.csv"
write.csv(schedule_time_df() %>% select(Status, Sample, Step, Time, Duration, Wait_Until_Next), time_path, row.names = FALSE)
files_to_zip <- c(files_to_zip, time_path)
}
if("sample_sched" %in% input$reportContents) {
req(schedule_sample_df())
sample_path <- "schedule_by_sample.csv"
write.csv(schedule_sample_df(), sample_path, row.names = TRUE)
files_to_zip <- c(files_to_zip, sample_path)
}
zip::zip(zipfile = file, files = files_to_zip)
},
contentType = "application/zip"
)
# --- Modals for Help and Downloads ---
observeEvent(input$toggleAdvanced, { shinyjs::toggle(id = "advancedOptions", anim = TRUE) })
observeEvent(input$downloadPlotModal, { showModal(modalDialog(title = "Download Plot", selectInput("plotFormat", "File Format:", c("pdf", "png", "jpeg", "tiff")), numericInput("plotWidth", "Width (inches):", 10, min = 1, max = 20), numericInput("plotHeight", "Height (inches):", 8, min = 1, max = 20), checkboxInput("plotShowLegend", "Show Legend", input$showLegendMain), footer = tagList(modalButton("Cancel"), downloadButton("confirmDownloadPlot", "Download")))) })
observeEvent(input$downloadReportModal, {
showModal(modalDialog(title = "Download Full Report", p("Select the components to include in the .zip archive."),
checkboxGroupInput("reportContents", "Include:",
choices = c(
"Gantt Chart (PDF)" = "plot",
"Full Session (.json)" = "params_json",
"Protocol Parameters (.csv)" = "params_csv",
"Chronological Schedule (CSV)" = "time_sched",
"Per-Sample Schedule (CSV)" = "sample_sched"
),
selected = c("plot", "params_json", "time_sched", "sample_sched")
),
footer = tagList(modalButton("Cancel"), downloadButton("confirmDownloadReport", "Download .zip")))
)
})
observeEvent(input$help_saveload, { showModal(modalDialog(title = "Save & Load Functionality", tags$p(tags$strong("Save Session (.json):"), "Saves your complete experiment, including the protocol, sample names, buffer times, colors, and all other settings. This is the recommended way to save your work for full reproducibility."), tags$p(tags$strong("Save Protocol (.csv):"), "Saves only the table of protocol steps (name, duration, wait time). This is useful for sharing just the core protocol with a colleague or for use in other programs."), tags$p(tags$strong("Upload File:"), "You can upload either a full .json session file to restore all settings, or a legacy .csv protocol file to overwrite only the current step definitions."), easyClose = TRUE, footer = modalButton("Close"))) })
}
# --- 7. Run the App ---
# ------------------------------------------------------------------------------
shinyApp(ui = ui, server = server)
renv::snapshot()
renv::restore()
q()
